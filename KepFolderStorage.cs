using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using YamlDotNet.Serialization.NamingConventions;
using YamlDotNet.Serialization;
using KepwareSync.Model;
using KepwareSync.Serializer;
using YamlDotNet.Serialization.NodeTypeResolvers;
using System.Security.AccessControl;
using KepwareSync.Configuration;

namespace KepwareSync
{
    internal class KepFolderStorage
    {
        private readonly YamlSerializer m_yamlSerializer;
        private readonly CsvTagSerializer m_csvTagSerializer;
        private readonly DataTypeEnumConverterProvider m_dataTypeEnumConverterProvider;
        private readonly ILogger<KepFolderStorage> m_logger;
        private readonly KepStorageOptions m_kepStorageOptions;

        public KepFolderStorage(ILogger<KepFolderStorage> logger, KepStorageOptions kepStorageOptions)
        {
            m_logger = logger;
            m_kepStorageOptions = kepStorageOptions;
            m_yamlSerializer = new YamlSerializer();
            m_csvTagSerializer = new CsvTagSerializer();
            m_dataTypeEnumConverterProvider = new DataTypeEnumConverterProvider();
        }

        private void DeleteDirectories(string baseDir, IEnumerable<string> names)
        {
            // Delete all channel directories that are not in the current project   
            foreach (var dir in names)
            {
                var folderPath = Path.Combine(baseDir, dir);
                if (Directory.Exists(folderPath))
                {
                    Directory.Delete(folderPath, true);
                    m_logger.LogInformation("Deleted folder: {FolderPath}", folderPath);
                }
            }
        }

        public async Task ExportDevices(Channel channel, DeviceCollection? devices)
        {

            DirectoryInfo baseDirInfo = new DirectoryInfo(m_kepStorageOptions.Directory ?? "ExportedYaml");
            string channelFolder = Path.Combine(baseDirInfo.FullName, channel.Name);
            var deviceDirsToDelete = new DirectoryInfo(channelFolder).GetDirectories().Select(dir => dir.Name)
                            .ToHashSet(StringComparer.OrdinalIgnoreCase);
            await ExportDevices(channel, channelFolder, deviceDirsToDelete);
            DeleteDirectories(channelFolder, deviceDirsToDelete);
        }

        private async Task<(int exportedDevices, int exportedTags)> ExportDevices(Channel channel, string channelFolder, HashSet<string> deviceDirsToDelete)
        {
            if (channel?.Devices == null)
                return (0, 0);

            int exportedDevices = 0, exportedTags = 0;

            foreach (var device in channel.Devices)
            {
                ++exportedDevices;
                var deviceFolder = Path.Combine(channelFolder, device.Name);
                var dataTypeConverter = m_dataTypeEnumConverterProvider.GetDataTypeEnumConverter(device.GetDynamicProperty<string>(Properties.DeviceDriver));
                deviceDirsToDelete.Remove(device.Name);

                try
                {
                    // Export Device
                    var deviceFile = Path.Combine(deviceFolder, "device.yaml");
                    await m_yamlSerializer.SaveAsYaml(deviceFile, device);

                    if (device.Tags != null)
                    {
                        await m_csvTagSerializer.ExportTagsAsync(Path.Combine(deviceFolder, "tags.csv"), device.Tags.Items, dataTypeConverter);
                        exportedTags += device.Tags.Items.Count;
                    }

                    if (device.TagGroups != null)
                    {
                        foreach (var tagGroup in device.TagGroups.Where(grp => !grp.IsAutogenerated))
                        {
                            var tagGroupFolder = Path.Combine(deviceFolder, tagGroup.Name);

                            // Export TagGroup
                            var tagGroupFile = Path.Combine(tagGroupFolder, "tagGroup.yaml");
                            await m_yamlSerializer.SaveAsYaml(tagGroupFile, tagGroup);

                            if (tagGroup.Tags != null)
                            {
                                await m_csvTagSerializer.ExportTagsAsync(Path.Combine(tagGroupFolder, "tags.csv"), tagGroup.Tags.Items, dataTypeConverter);
                                exportedTags += tagGroup.Tags.Items.Count;
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    m_logger.LogError(ex, "Error exporting device '{DeviceName}' to YAML.", device.Name);
                }
            }
            return (exportedDevices, exportedTags);
        }

        public async Task ExportChannelsAsYamlAsync(ChannelCollection? channels)
        {
            if (channels == null) return;

            try
            {
                DirectoryInfo baseDirInfo = new DirectoryInfo(m_kepStorageOptions.Directory ?? "ExportedYaml");


                if (!baseDirInfo.Exists)
                    baseDirInfo.Create();

                var channelDirsToDelete = baseDirInfo.GetDirectories().Select(dir => dir.Name)
                    .ToHashSet(StringComparer.OrdinalIgnoreCase);

                List<(string baseDir, IEnumerable<string> folderNames)> foldersToDelete = new();
                int exportedChannels = 0, exportedDevices = 0, exportedTags = 0;
                foreach (var channel in channels)
                {
                    var channelFolder = Path.Combine(baseDirInfo.FullName, channel.Name);
                    channelDirsToDelete.Remove(channel.Name);
                    ++exportedChannels;
                    try
                    {
                        // Export Channel
                        var channelFile = Path.Combine(channelFolder, "channel.yaml");
                        await m_yamlSerializer.SaveAsYaml(channelFile, channel);
                    }
                    catch (Exception ex)
                    {
                        m_logger.LogError(ex, "Error exporting channel '{ChannelName}' to YAML.", channel.Name);
                        continue;
                    }

                    if (channel.Devices != null)
                    {
                        var deviceDirsToDelete = new DirectoryInfo(channelFolder).GetDirectories().Select(dir => dir.Name)
                            .ToHashSet(StringComparer.OrdinalIgnoreCase);

                        var count = await ExportDevices(channel, channelFolder, deviceDirsToDelete);

                        foldersToDelete.Add((channelFolder, deviceDirsToDelete));
                    }
                }

                try
                {
                    DeleteDirectories(baseDirInfo.FullName, channelDirsToDelete);

                    foreach (var (baseDir, folderNames) in foldersToDelete)
                    {
                        DeleteDirectories(baseDir, folderNames);
                    }
                }
                catch (Exception ex)
                {
                    m_logger.LogError(ex, "Error deleting directories.");
                }

                // Log information: Exported channels to YAML successfully (including target directory, count of channels, devices, and tags).
                m_logger.LogInformation(
                    "Exported channels to YAML successfully. Target directory: {TargetDirectory}, Channels: {ChannelCount}, Devices: {DeviceCount}, Tags: {TagCount}",
                    baseDirInfo.FullName,
                    exportedChannels,
                    exportedDevices,
                    exportedTags);

            }
            catch (Exception ex)
            {
                m_logger.LogError(ex, "Error exporting channels to YAML.");
            }
        }
    }
}
